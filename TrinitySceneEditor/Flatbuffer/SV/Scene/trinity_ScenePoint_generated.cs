// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace Titan.TrinityScene
{

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

public struct trinity_ScenePoint : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_3_3(); }
  public static trinity_ScenePoint GetRootAstrinity_ScenePoint(ByteBuffer _bb) { return GetRootAstrinity_ScenePoint(_bb, new trinity_ScenePoint()); }
  public static trinity_ScenePoint GetRootAstrinity_ScenePoint(ByteBuffer _bb, trinity_ScenePoint obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public trinity_ScenePoint __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string PointName { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetPointNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetPointNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetPointNameArray() { return __p.__vector_as_array<byte>(4); }
  public Vec3f? PointLocation { get { int o = __p.__offset(6); return o != 0 ? (Vec3f?)(new Vec3f()).__assign(o + __p.bb_pos, __p.bb) : null; } }
  public byte PointUnk { get { int o = __p.__offset(8); return o != 0 ? __p.bb.Get(o + __p.bb_pos) : (byte)0; } }

  public static Offset<Titan.TrinityScene.trinity_ScenePoint> Createtrinity_ScenePoint(FlatBufferBuilder builder,
      StringOffset point_nameOffset = default(StringOffset),
      Vec3fT point_location = null,
      byte point_unk = 0) {
    builder.StartTable(3);
    trinity_ScenePoint.AddPointLocation(builder, Vec3f.Pack(builder, point_location));
    trinity_ScenePoint.AddPointName(builder, point_nameOffset);
    trinity_ScenePoint.AddPointUnk(builder, point_unk);
    return trinity_ScenePoint.Endtrinity_ScenePoint(builder);
  }

  public static void Starttrinity_ScenePoint(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddPointName(FlatBufferBuilder builder, StringOffset pointNameOffset) { builder.AddOffset(0, pointNameOffset.Value, 0); }
  public static void AddPointLocation(FlatBufferBuilder builder, Offset<Vec3f> pointLocationOffset) { builder.AddStruct(1, pointLocationOffset.Value, 0); }
  public static void AddPointUnk(FlatBufferBuilder builder, byte pointUnk) { builder.AddByte(2, pointUnk, 0); }
  public static Offset<Titan.TrinityScene.trinity_ScenePoint> Endtrinity_ScenePoint(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Titan.TrinityScene.trinity_ScenePoint>(o);
  }
  public static void Finishtrinity_ScenePointBuffer(FlatBufferBuilder builder, Offset<Titan.TrinityScene.trinity_ScenePoint> offset) { builder.Finish(offset.Value); }
  public static void FinishSizePrefixedtrinity_ScenePointBuffer(FlatBufferBuilder builder, Offset<Titan.TrinityScene.trinity_ScenePoint> offset) { builder.FinishSizePrefixed(offset.Value); }
  public trinity_ScenePointT UnPack() {
    var _o = new trinity_ScenePointT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(trinity_ScenePointT _o) {
    _o.PointName = this.PointName;
    _o.PointLocation = this.PointLocation.HasValue ? this.PointLocation.Value.UnPack() : null;
    _o.PointUnk = this.PointUnk;
  }
  public static Offset<Titan.TrinityScene.trinity_ScenePoint> Pack(FlatBufferBuilder builder, trinity_ScenePointT _o) {
    if (_o == null) return default(Offset<Titan.TrinityScene.trinity_ScenePoint>);
    var _point_name = _o.PointName == null ? default(StringOffset) : builder.CreateString(_o.PointName);
    return Createtrinity_ScenePoint(
      builder,
      _point_name,
      _o.PointLocation,
      _o.PointUnk);
  }
}

public class trinity_ScenePointT
{
  public string PointName { get; set; }
  public Vec3fT PointLocation { get; set; }
  public byte PointUnk { get; set; }

  public trinity_ScenePointT() {
    this.PointName = null;
    this.PointLocation = new Vec3fT();
    this.PointUnk = 0;
  }
  public static trinity_ScenePointT DeserializeFromBinary(byte[] fbBuffer) {
    return trinity_ScenePoint.GetRootAstrinity_ScenePoint(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    trinity_ScenePoint.Finishtrinity_ScenePointBuffer(fbb, trinity_ScenePoint.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


}
